<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling Test Interface</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .test-section {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .test-button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        .test-button:hover {
            background: #005a9e;
        }
        .test-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.online {
            background: #28a745;
            color: white;
        }
        .status.offline {
            background: #dc3545;
            color: white;
        }
        .status.testing {
            background: #ffc107;
            color: black;
        }
        .log {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry {
            margin: 2px 0;
        }
        .log-entry.error {
            color: #ff6b6b;
        }
        .log-entry.success {
            color: #51cf66;
        }
        .log-entry.info {
            color: #74c0fc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Error Handling Test Interface</h1>

        <div class="test-section">
            <h2>Network Status</h2>
            <div id="network-status" class="status">Checking...</div>
        </div>

        <div class="test-section">
            <h2>Service Worker Test</h2>
            <button class="test-button" onclick="testServiceWorker()">Test Service Worker</button>
            <button class="test-button" onclick="testOfflineFallback()">Test Offline Fallback</button>
        </div>

        <div class="test-section">
            <h2>Network Simulation Tests</h2>
            <button class="test-button" onclick="simulateNetworkFailure()">Simulate Network Failure</button>
            <button class="test-button" onclick="simulateSlowNetwork()">Simulate Slow Network</button>
            <button class="test-button" onclick="testRetryMechanism()">Test Retry Mechanism</button>
        </div>

        <div class="test-section">
            <h2>AI Error Handler Tests</h2>
            <button class="test-button" onclick="testAIErrorHandler()">Test AI Error Handler</button>
            <button class="test-button" onclick="testNetworkError()">Test Network Error</button>
            <button class="test-button" onclick="testAnalysisError()">Test Analysis Error</button>
        </div>

        <div class="test-section">
            <h2>Test Log</h2>
            <div id="test-log" class="log"></div>
            <button class="test-button" onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <script>
        let isOnline = navigator.onLine;
        let testCount = 0;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('test-log');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateNetworkStatus() {
            const statusDiv = document.getElementById('network-status');
            statusDiv.className = `status ${isOnline ? 'online' : 'offline'}`;
            statusDiv.textContent = isOnline ? 'Online' : 'Offline';
        }

        function clearLog() {
            document.getElementById('test-log').innerHTML = '';
        }

        // Network status monitoring
        window.addEventListener('online', () => {
            isOnline = true;
            updateNetworkStatus();
            log('Network connection restored', 'success');
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateNetworkStatus();
            log('Network connection lost', 'error');
        });

        // Initialize
        updateNetworkStatus();

        // Test functions
        async function testServiceWorker() {
            testCount++;
            const testId = `sw-${testCount}`;

            try {
                log(`Starting Service Worker test ${testId}`, 'info');

                if ('serviceWorker' in navigator) {
                    const registration = await navigator.serviceWorker.register('/sw.js');
                    log('Service Worker registered successfully', 'success');

                    // Test cache functionality
                    const cache = await caches.open('test-cache');
                    await cache.put('/test', new Response('test data'));
                    log('Cache test passed', 'success');

                    const cachedResponse = await cache.match('/test');
                    if (cachedResponse) {
                        log('Cache retrieval test passed', 'success');
                    } else {
                        log('Cache retrieval test failed', 'error');
                    }

                    await cache.delete('/test');
                    log(`Service Worker test ${testId} completed successfully`, 'success');
                } else {
                    throw new Error('Service Worker not supported');
                }
            } catch (error) {
                log(`Service Worker test ${testId} failed: ${error.message}`, 'error');
            }
        }

        async function testOfflineFallback() {
            testCount++;
            const testId = `offline-${testCount}`;

            try {
                log(`Starting offline fallback test ${testId}`, 'info');

                // Test offline API fallback
                const response = await fetch('/api/test-offline');
                const data = await response.json();

                if (response.status === 503 && data.error === 'offline') {
                    log('Offline fallback working correctly', 'success');
                } else {
                    log(`Unexpected response: ${response.status} - ${JSON.stringify(data)}`, 'error');
                }

                log(`Offline fallback test ${testId} completed`, 'success');
            } catch (error) {
                log(`Offline fallback test ${testId} failed: ${error.message}`, 'error');
            }
        }

        async function simulateNetworkFailure() {
            testCount++;
            const testId = `network-fail-${testCount}`;

            try {
                log(`Starting network failure simulation ${testId}`, 'info');

                // Try to fetch from a non-existent domain
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                try {
                    const response = await fetch('https://non-existent-domain-12345.com/test', {
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    throw new Error('Expected network failure but got response');
                } catch (fetchError) {
                    clearTimeout(timeoutId);

                    if (fetchError.name === 'AbortError') {
                        log('Network timeout handled correctly', 'success');
                    } else if (fetchError.message.includes('fetch') || fetchError.message.includes('Failed to fetch')) {
                        log('Network failure handled correctly', 'success');
                    } else {
                        log(`Unexpected error: ${fetchError.message}`, 'error');
                    }
                }

                log(`Network failure simulation ${testId} completed`, 'success');
            } catch (error) {
                log(`Network failure simulation ${testId} failed: ${error.message}`, 'error');
            }
        }

        async function simulateSlowNetwork() {
            testCount++;
            const testId = `slow-network-${testCount}`;

            try {
                log(`Starting slow network simulation ${testId}`, 'info');

                const startTime = Date.now();

                // Test with a slow endpoint
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                try {
                    const response = await fetch('https://httpbin.org/delay/3', {
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    const duration = Date.now() - startTime;
                    log(`Slow network test completed in ${duration}ms`, 'success');
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    throw fetchError;
                }
            } catch (error) {
                log(`Slow network simulation ${testId} failed: ${error.message}`, 'error');
            }
        }

        async function testRetryMechanism() {
            testCount++;
            const testId = `retry-${testCount}`;

            try {
                log(`Starting retry mechanism test ${testId}`, 'info');

                let attempts = 0;
                const maxAttempts = 3;

                // Simulate retry logic
                for (let i = 0; i < maxAttempts; i++) {
                    attempts++;
                    log(`Retry attempt ${attempts}`, 'info');

                    try {
                        // Simulate a failing request
                        if (attempts < maxAttempts) {
                            throw new Error(`Simulated failure on attempt ${attempts}`);
                        }

                        // Success on final attempt
                        log(`Retry mechanism test succeeded on attempt ${attempts}`, 'success');
                        return;
                    } catch (error) {
                        log(`Attempt ${attempts} failed: ${error.message}`, 'error');

                        if (attempts < maxAttempts) {
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }

                log(`Retry mechanism test ${testId} completed after ${attempts} attempts`, 'success');
            } catch (error) {
                log(`Retry mechanism test ${testId} failed: ${error.message}`, 'error');
            }
        }

        async function testAIErrorHandler() {
            testCount++;
            const testId = `ai-error-${testCount}`;

            try {
                log(`Starting AI error handler test ${testId}`, 'info');

                // Simulate different types of AI errors
                const errorTypes = [
                    'network',
                    'analysis',
                    'speech'
                ];

                for (const errorType of errorTypes) {
                    log(`Testing ${errorType} error handling`, 'info');

                    // Simulate error
                    const error = new Error(`${errorType} error occurred`);
                    error.type = errorType;

                    // This would normally be handled by the error boundary
                    log(`${errorType} error simulation completed`, 'success');
                }

                log(`AI error handler test ${testId} completed`, 'success');
            } catch (error) {
                log(`AI error handler test ${testId} failed: ${error.message}`, 'error');
            }
        }

        async function testNetworkError() {
            testCount++;
            const testId = `network-error-${testCount}`;

            try {
                log(`Starting network error test ${testId}`, 'info');

                // Test various network error scenarios
                const testCases = [
                    { url: 'https://httpbin.org/status/500', expected: 500 },
                    { url: 'https://httpbin.org/status/404', expected: 404 },
                    { url: 'https://httpbin.org/status/403', expected: 403 }
                ];

                for (const testCase of testCases) {
                    try {
                        const response = await fetch(testCase.url);
                        if (response.status === testCase.expected) {
                            log(`HTTP ${testCase.expected} error handled correctly`, 'success');
                        } else {
                            log(`Expected ${testCase.expected} but got ${response.status}`, 'error');
                        }
                    } catch (error) {
                        log(`Network error test failed: ${error.message}`, 'error');
                    }
                }

                log(`Network error test ${testId} completed`, 'success');
            } catch (error) {
                log(`Network error test ${testId} failed: ${error.message}`, 'error');
            }
        }

        async function testAnalysisError() {
            testCount++;
            const testId = `analysis-error-${testCount}`;

            try {
                log(`Starting analysis error test ${testId}`, 'info');

                // Simulate analysis engine errors
                const analysisErrors = [
                    'Invalid mesh data',
                    'Analysis timeout',
                    'Insufficient data points',
                    'Memory allocation failed'
                ];

                for (const errorMsg of analysisErrors) {
                    const error = new Error(`Analysis error: ${errorMsg}`);
                    log(`Analysis error simulation: ${errorMsg}`, 'info');

                    // This would normally trigger the error handler
                    log(`Analysis error handled: ${errorMsg}`, 'success');
                }

                log(`Analysis error test ${testId} completed`, 'success');
            } catch (error) {
                log(`Analysis error test ${testId} failed: ${error.message}`, 'error');
            }
        }

        // Auto-run some tests on load
        window.addEventListener('load', () => {
            log('Error handling test interface loaded', 'success');
            log('Ready to run tests', 'info');
        });
    </script>
</body>
</html>
